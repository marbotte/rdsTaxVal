---
title: "rdsTaxVal"
format: 
  gfm:
    df_print: kable
---

<!-- badges: start -->
[![R-CMD-check](https://github.com/marbotte/rdsTaxVal/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/marbotte/rdsTaxVal/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->


```{r setup}
require(knitr)
```


## Installing the package

You may install the `rdsTaxVal` package with the following command:

```r
if(!require(devtools)){install.packages("devtools")}
devtools::install_github("marbotte/rdsTaxVal")
```
## Loading the package

```{r}
library(rdsTaxVal)
```


## Reading the files 

```{r}
rdsBST<-readRDS("../data_google/4.rdsProyectos/dataRedBSTCol.rds")
rdsTDF<-readRDS("../data_google/4.rdsProyectos/dataTDF.rds")
#rdsTDF$taxonomy$family<-as.character(rdsTDF$taxonomy$family)
```

## Creating the oneTable objects


```{r}
taxoBST <- new_taxo_oneTab(rdsBST$taxonomy)
taxoTDF <- new_taxo_oneTab(rdsTDF$taxonomy, currentFormat = "oneTable", taxonRanks_names = c(family="family", genus="genus",species="sp_epithet"), taxonRanks_epithetized = c("sp_epithet"))

taxoBST[arrayInd(which(as.matrix(taxoBST) %in% c("","N/D","NA","N/A")), .dim=dim(taxoBST), useNames = T)] <- NA
taxoTDF[arrayInd(which(as.matrix(taxoTDF) %in% c("","N/D","NA","N/A")), .dim=dim(taxoTDF), useNames = T)] <- NA
taxoBST_initial<-taxoBST
taxoTDF_initial<-taxoTDF
```

## Full diagnostic

```{r}
suggestedBST<-fullTaxonomicDiagnostic(taxoBST)
kable(head(suggestedBST$suggested))
```


```{r}
suggestedTDF<-fullTaxonomicDiagnostic(taxoTDF)
kable(head(suggestedTDF$suggested))
```

### Exporting the full Diagnostic in Excel

```{r}
fileDiagnosticBST<- "../suggestedBST.xlsx"
exportXlDiagnostic(suggestedBST,fileDiagnosticBST,overwrite = T)
```

```{r}
fileDiagnosticTDF<-"../suggestedTDF.xlsx"
exportXlDiagnostic(suggestedTDF,fileDiagnosticTDF,overwrite = T)
```

Here you might want to:

* check on the excel file which correction you do not want to apply (delete the rows in the sheet "suggested")
* load back the file with the function `importXlDiagnostic`
* use the function `correct` to apply the corrections to the R object directly



## Going into details



### Manage spaces in the taxonomy table

```{r}
suggested_spaces_BST<-checkSpace(taxoBST)
kable(suggested_spaces_BST)
taxoBST<-correct(taxoBST,suggested_spaces_BST)
```


```{r}
suggested_spaces_TDF<-checkSpace(taxoTDF)
kable(suggested_spaces_TDF)
taxoTDF<-correct(taxoTDF,suggested_spaces_TDF)
table(taxoRanks(taxoTDF))
```

### Manage undetermined taxa

```{r}
suggested_undetermined_BST<-checkUndetermited(taxoBST)
kable(head(suggested_undetermined_BST))
taxoBST<-correct(taxoBST,suggested_undetermined_BST)
```

```{r}
suggested_undetermined_TDF<-checkUndetermited(taxoTDF)
kable(head(suggested_undetermined_TDF))
taxoTDF<-correct(taxoTDF,suggested_undetermined_TDF)
table(taxoRanks(taxoTDF))
```


### Structural problems
#### Are genera always in the same family

```{r}
suggested_unicity_familyBST<-checkUnicityRankSup(taxoBST, rank = "genus", superior="family")
kable(head(suggested_unicity_familyBST))
##correctUndetermined(taxoBST,suggested_unicity_familyBST)
taxoBST<-correct(taxoBST, suggested_unicity_familyBST)
```

```{r}
suggested_unicity_familyTDF<-checkUnicityRankSup(taxoTDF, rank="genus",superior="family")
kable(head(suggested_unicity_familyTDF))
taxoTDF<- correct(taxoTDF,suggested_unicity_familyTDF)
table(taxoRanks(taxoTDF))
```

#### Are taxonomic codes always associated with the same information

```{r}
suggested_taxoCodeBST <- checkUnicityCodetax(taxoBST,"takeFirst")
kable(head(showUnicityCodetax(suggested_taxoCodeBST,"suggested")))
taxoBST<-correct(taxoBST, suggested_taxoCodeBST)
```

```{r}
suggested_taxoCodeTDF <- checkUnicityCodetax(taxoTDF,"takeFirst")
kable(head(showUnicityCodetax(suggested_taxoCodeTDF,"suggested")))
taxoTDF<-correct(taxoTDF, suggested_taxoCodeTDF)
table(taxoRanks(taxoTDF))
```

### Using the gbif backbone to get suggested corrections

```{r}
suggested_species_gbif_BST<-checkGbif(taxoBST,rankCheck="species")
kable(head(suggested_species_gbif_BST$suggested))
taxoBST<-correct(taxoBST,suggested_species_gbif_BST)
```

```{r}
suggested_genus_gbif_BST<-checkGbif(taxoBST,rankCheck="genus")
kable(head(suggested_genus_gbif_BST$suggested))
taxoBST<-correct(taxoBST,suggested_genus_gbif_BST)
```

```{r}
suggested_family_gbif_BST<-checkGbif(taxoBST,rankCheck="family")
kable(head(suggested_family_gbif_BST$suggested))
taxoBST<-correct(taxoBST,suggested_family_gbif_BST)
```


```{r}
suggested_species_gbif_TDF<-checkGbif(taxoTDF,rankCheck="species")
kable(head(suggested_species_gbif_TDF$suggested))
taxoTDF<-correct(taxoTDF,suggested_species_gbif_TDF)
```

```{r}
suggested_genus_gbif_TDF<-checkGbif(taxoTDF,rankCheck="genus")
kable(head(suggested_genus_gbif_TDF$suggested))
taxoTDF<-correct(taxoTDF,suggested_genus_gbif_TDF)
```

```{r}
suggested_family_gbif_TDF<-checkGbif(taxoTDF,rankCheck="family")
kable(head(suggested_family_gbif_TDF$suggested))
taxoTDF<-correct(taxoTDF,suggested_family_gbif_TDF)
```


## Other useful functions

### Information at a particular rank

The `getRank` function returns the name of taxa at a particular rank (NA if the lower rank with information is higher than the one queried).

```{r}
table(getRank(taxoBST, rank="family"))
```

### Lower rank for each row
It is often useful to know the lowest rank that might apply for each register:

```{r}
taxoRanks(taxoBST)[1:100]
```

Note that no analysis is done here, which means that if there is wrong information in a column represented a rank, it will not be discarded. See the following example where we count the ranks before and after automatic corrections:

```{r}
table(taxoRanks(taxoBST_initial))
table(taxoRanks(taxoBST))
```


### Extracting an epithet from a complete name



The `extractEpithet` function allows us to extract an epithet:

```{r}
extractEpithet("Espeletia grandiflora")
extractEpithet("Espeletia grandiflora var. boyacana")
```

While the latest example works well , you should prefer the form without qualifiers:

```{r}
extractEpithet("Espeletia grandiflora boyacana")
```

Used without any other argument, the function will basically extract the last word of a string, however, if you give the higher rank, it will check whether they actually correspond:

```{r}
extractEpithet("Espeletia grandiflora", higherTaxon = "Espeletia")
extractEpithet("Magnolia grandiflora", higherTaxon = "Magnolia")
```


```{r}
extractEpithet("Espeletia grandiflora", higherTaxon = "Magnolia")
```


Of course this function may be applied on more than one name:
```{r}
speciesTableFromGbif<-suggested_species_gbif_BST$analysedGbif[1:30]
(spNames<-sapply(speciesTableFromGbif,function(x)x$canonicalname))
(gnNames<-sapply(speciesTableFromGbif,function(x)
  {hr<-x$higherRanks
  return(hr$canonicalname[hr$rank=="genus"])}))
```

```{r}
extractEpithet(spNames,gnNames)
```


### Getting clean taxonomy/taxonomical classification from gbif and adding higher ranks to the table

If the Gbif check has been done, through the `gbifCheck` function

Whenever you have done a search in Gbif, you may extract a complete list of taxa and their higher taxa, from the GBIF backbone:
```{r}
(tdfFamilies<-taxoTDF[taxoRanks(taxoTDF)=="family",])
kable(tabClassifTdfFamilies<-extractCompleteTaxo(suggested_family_gbif_BST$analysedGbif))
```

Note that since the `fullTaxonomicDiagnostic` function (when applied with the checks="gbif" option) has an analysedGbif component, function `extractCompleteTaxo` may be applied on it too!

Then it might be useful to extract a taxonomical table on a column-based format:

```{r}
tabTaxoFromRank(tabClassifTdfFamilies, rank = "order")
```

And finally we can merge with the register table, to obtain:

```{r}
res<-addHigherRanks(tdfFamilies,suggested_family_gbif_BST$analysedGbif,ranks = c("phylum","class","order"),mergeOn="family")
kable(res)
```


